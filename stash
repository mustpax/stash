#!/usr/bin/env python
'''stash is a utility for operating on files across many folders.
'''
import os
import sys
import json

STASH_FILE = '.stash'

def __stash_file_path():
    return os.path.expanduser(os.path.join('~', STASH_FILE))

def __ensure_stash_file_exists():
    if not os.path.exists(__stash_file_path()):
        with open(__stash_file_path(), 'w') as f:
            f.write('{}')

def __update(func):
    with open(__stash_file_path(), 'r+') as f:
        try:
            data = json.load(f)
        except ValueError:
            sys.stderr.write('Stash file corrupted. Delete this file to continue: %s\n' % __stash_file_path())
            return 1

        data = func(data)
        f.seek(0)
        json.dump(data, f, sort_keys=True, indent=4, separators=(',', ': '))
        f.truncate()
    return 0

def stash(filename):
    __ensure_stash_file_exists()

    filename = os.path.abspath(filename)
    if not os.path.exists(filename):
        sys.stderr.write('File not found: %s\n' % filename)
        return 1

    def f(data):
        print 'Adding file as last item:', filename
        if 'files' not in data:
            data['files'] = []
        data['files'].append(filename)
        return data

    return __update(f)

def pop():
    __ensure_stash_file_exists()

    def f(data):
        if 'files' not in data or len(data['files']) == 0:
            sys.stderr.write('Error: Stash empty. Cannot pop.\n')
            return data
        print data['files'].pop()
        return data

    return __update(f)

USAGE = '''\
Usage: stash [command] [file]
If command is omitted 'stash' is assumed
Commands:
   stash: save given file at the top of the stash
   pop:   remove the file at the top of the stash and write it its name to stdout
'''

def usage():
    print >>sys.stderr, USAGE


COMMANDS = {
        'stash': stash,
        'p': pop,
        'pop': pop,
        }

def main(args):
    if len(args) == 0 or len(args) > 2:
        usage()
        return 1

    cmd = args[0]
    if cmd in COMMANDS:
        return COMMANDS[cmd](*args[1:])

    if os.path.exists(cmd):
        return stash(args[0])

    print >>sys.stderr, 'Unrecognized command:', cmd
    usage()
    return 1

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

